(setq A '(X1 & - X2 & - x3 ||  P || Z))
(setq B '(x1 || x2))
(setq C '(X4 & X1 & X2 & - x3))
(setq D '(X1 || X2 & X3))
(setq E '( X & Y ))
(setq F '( X1 & - X1))

(defun Func (L)
    (setq tmp (car L))
    (cond  ((null tmp) '())
           ((eq tmp '-) ( cons (cadr L) (Func (cddr L))))
           ((eq tmp '||) (cons '& (Func ( cdr L))))
           ((eq tmp '&) (cons '|| (Func ( cdr L))))
           ((atom tmp) (cons (cons '- ( list tmp)) (Func (cdr L))))
           (T (cons (Func tmp) (Func (cdr L))))
    )
)

(defun is_member_2 (elem L1)
    (cond ((null L1) NIL)
          ((atom (car L1)) (is_member_2 elem (cdr L1)))
          ((eq elem (cadar L1)) T) 
          (T (is_member_2 elem (cdr L1)))
    )
)


(defun is_member (X L2)
    (cond ((null L2) NIL)
          ((atom X) (or (eq X (car L2))(is_member X (cdr L2)) ) )
          (T  (is_member_2 (cadr X) L2))
    )
)

(defun split_list (L)
 ( sep L '() '())
)

(defun sep (L1 L2 L3)
    (setq tmp (car L1))
    (cond ((null L1) (cons L3 L2))
          ((eq tmp '&) (sep (cdr L1) (cons L3 L2 ) '()))
           ((atom L1) (member L1 L2))
           ((eq tmp '||) (sep (cdr L1) L2 L3))
          ((atom tmp) (sep (cdr L1) L2 (cons tmp L3)))
          (T (sep (cdr L1) L2 (cons tmp L3)))
    
    )
)

(defun to_set (L)
    (transform_set L '())
)

(defun transform_set (L1 L2)
    (cond   ((null L1) L2) 
            ((is_member (car L1) L2) (transform_set (cdr L1) L2))
            (T (transform_set (cdr L1) (cons (car L1) L2)))
    )
)

(defun simpler (L)
    (mapcar 'to_set L)
)

(defun preprocess (L)
  (simpler (split_list (Func L)))
)

(defun make_pairs1 (L1 L2)
    (cond ((null L1) NIL)
          ((null L2) L1)
          (T (append (make_pairs L2 (car L1)) (make_pairs1 (cdr L1) L2)))
    )
)

(defun make_pairs (L2 elem)
    (cond ((null L2) '())
        ((not (eq elem (car L2))) ( cons (list elem (car L2)) (make_pairs (cdr L2) elem)))
        (( cons (list (car L2)) (make_pairs (cdr L2) elem) ))
    )
)

(defun create_list (elem n)
    (cond ((= n 0) NIL)
          ((= n 1) (list elem))
          (T (cons elem (create_list elem (- n 1))))
    )
)

(defun multy_chain (L1 L2)
    (cond ((null L2) NIL)
    (T (append (multy_chain L1 (cdr L2)) (mapcar 'cons (create_list (car L2) (length L1)) L1)))
)
)

(defun multiply1 (L)
    (multiply2 (make_pairs1 (car L) (cadr L)) (cddr L) )
    )

(defun multiply2 (L1 L2)
    (cond ((null L2) L1)
          (T (multiply2 (multy_chain L1 (car L2)) (cdr L2)))
)
)

(defun convert (L N)
    (cond ((null L) NIL)
          ((atom L) (list L))
          ((and (eq (length L) 2) (eq (car L) '-)) (list L))
          ((= N 0) (append (list (car L)) (convert (cdr L) (+ N 1)) )) 
          ( T (append (cons '&  (list (car L))) (convert (cdr L) (+ N 1) )) )
    )
)

(defun to_dnf (L N)
 (cond ((null L) NIL)
       ((= N 0) (append (convert (car L) 0)  (to_dnf (cdr L) ( + N 1)) ))
       (T (append (cons '|| (convert (car L) 0)) (to_dnf (cdr L) (+ N 1) )) )
 )
)

(defun main (L)
(to_dnf (multiply1 (simpler (split_list (Func L)))) 0) 
)

(print  (main A) )
(print  (main B) )
(print  (main C) )
(print  (main D) )
(print  (main E) )
(print  (main F) )
